\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\title{TER, développement d'un émulateur de GameBoy}
\author{BERGER Mickaël \\ DIVET Joachim \\ VINARD Florian}
\date{17 Mai 2013}

\begin{document}
\maketitle

\tableofcontents
\chapter{Introduction}
	Dans le cadre de la 1ère année de Master Informatique à l'Université de Montpellier
	2, tous les élèves de la promotion ont été amenés à réaliser un projet
	sous tutelle, afin de mettre en pratique les compétences acquises
	durant nos précédentes années d'études, mais aussi et surtout de nous
	placer dans un contexte de réel travail sur un projet à réaliser.\\
	Ce Travail d'Étude de Recherche est donc un bon moyen de nous
	familiariser avec le type de travail qui pourra nous être demandé dans
	les années à venir, ainsi que de travailler nos démarches.
	Et c'est sur l'élaboration d'un Émulateur de console de jeu vidéo, et plus précisément de GameBoy,
	que nous avons choisi de travail1ler, plus que motivé par l'apport de
	connaissances que représente l'étude du comportement d'un processeur
	et sa simulation à partir de zéro.
	\\
	L'idée principale n'étant pas simplement de pouvoir rejouer aux jeux
	ayant bercé notre enfance, mais bien d'analyser et comprendre le
	fonctionnement d'un système d'émulation, qui reste très orienté bas
	niveau et "culture des composants", mais suffisemment accessible pour
	que notre travail puisse aboutir à un exemple concret, réalisé par nos
	soins.\\
	\\

\section{Définition du projet}
	Dès lors que notre choix fut fixé et validé par nos enseignants, il
	fut assez rapide de déterminer les grandes lignes du déroulement du
	projet, à savoir une première étape de documentation importante, afin
	de bien comprendre le fonctionnement de l'appareil. Une seconde partie
	de développement et donc de réelle simulation des différents aspects
	du système, et une dernière partie de perfectionnement et
	amélioration éventuelle de ce que nous aurons réalisé.

\chapter{Organisation du projet}
\section{Choix des outils}
Ce projet a été réalisé grâce à de nombreux outils, les voici, avec les raisons qui ont motivés nos choix.\\

\subsection{Environnement de travail}
Linux, car il est confortable pour les développeurs. Linux dispose dans la plupart des distributions classiques un ensemble d'outils pour développer tel que gcc, gdb etc...

\subsection{Langage}
C, un des langages les plus utilisés dans le monde de l'émulation. Il permet d'obtenir des executables compilés rapides, et selon les compilateurs de mettre en place des stratégies d'optimisations, afin de rendre l'émulateur plus fluide et rapide.

\subsection{Compilateur}
gcc, compilateur du langage C, il accepte beaucoup d'options permettant d'optimiser l'executable compilé.

\subsection{Librairie}
SDL, une librairie multimedia pour le langage C. Elle dispose d'un ensemble de primitives permettant de gérer tout ce qui est nécessaire pour créer un jeu en 2D et donc un émulateur de GameBoy: affichage de fenêtre, son, interruptions etc...

\subsection{Dépot}
Github, un site permettant de créer gratuitement un dépôt git. git est un logiciel de contrôle de version, permettant aux membres d'un même projet de modifier ce projet, en faisant en sorte que chacun puisse travailler sur la même version.

\subsection{IDE}
Le projet n'a pas été conçu avec un IDE particulier. Lors de la conception d'un projet il est propre à chacun d'utiliser l'IDE qui lui convient. Cependant la plupart du code a été édité avec l'éditeur de texte vim.
\section{Documentation}
\section{Etude de l'existant}
Il existe actuellement de nombreux émulateurs de GameBoy, pour rappel(si on l'a déjà dit dans l'intro) le but de ce projet n'était pas de rendre groboy un émulateur de renommée, mais bien de comprendre les rouages d'un émulateur de console de jeu.
Tous ces émulateurs ont leurs avantages par rapport aux autres:

(Liste des émulateurs principaux + avantages)
\subsection{Gambatte}
http://sourceforge.net/projects/gambatte/\\
Emulateur open source écrit en c++, un des émulateurs les plus fidèles au comportement de la GameBoy, il se base sur des tests réalisés directement sur une GameBoy.
\section{Articles de recherches}

\chapter{Etude du Hardware}
\section{CPU}
\subsection{Caractèristiques générales}
Le CPU de la GameBoy est un processeur 8 bits "Zilog 80" modifié, simplifié et adapté pour la GameBoy, son vrai nom est Sharp LR35902.
Une de ses spécificités est qu'il est capable de faire des opérations 16 bits.
Il est cadencé à 4,194304 MHz, et possède un peu moins de 512 opérations possibles.
\subsection{Registres}

Un registre est un espace mémoire interne au CPU, ce qui donne un accès en temps réel par le CPU à cet espace mémoire, aucun autre composant ne peut y accèder.
Le LR35902 possède 10 registres, 2 registres 16 bits PC et SP, et 8 registres 8 bits A, F, B, C, D, E, H, L.
Ce CPU est capable pour certaines opérations de coupler certains registres tels A et F, B et C, D et E, H et L, pour en faire des registres 16 bits, AF, BC, DE, HL.
Pratiquement tous les registres ont des rôles spécifiques:\\
Le registre PC appelé "Program Counter" est le registre pointant vers la prochaine opération à lire en mémoire.\\
Le registre SP appelé "Stack Pointer" est le registre pointant vers le sommet de la pile.\\
Le registre A appelé "Accumulator" est celui dans lequel la plupart des résultats des opérations sont stockés.\\
Le registre F appelé "Flags" est modifié par certaines circonstances.
Il possède 4 drapeaux, Z, N, H, C.
Le registre F étant rappelons le, un registre 8 bits, seuls les 4 bits de hauts niveaux servent pour les drapeaux:
ils sont disposés tels quels: Z N H C - - - -. Les 4 bits de bas niveaux sont eux toujours à 0.
Généralement, \\Le drapeau Z est à 1 lorsque le résultat d'une opération vaut 0, 0 sinon.\\
Le drapeau N est à 1 lorsque l'opération est une soustraction, 0 pour une addition, sinon il garde son état.\\
Le drapeau H est à 1 après une opération où les 4 bits de poids faibles de l'opérande ont subi un "débordement", dépassant 0xF, le drapeau est à 0 sinon.\\
Le drapeau C est à 1 après une opération où l'opérande a subi un débordement, dépassant 0xFF, le drapeau est à 0 sinon.\\
Les autres registres n'ont pas vraiment de rôles spécifiques mais servent pour beaucoup d'opérations.
\subsection{Instructions}
Une instruction est un calcul ou un ordre que va exécuter/commander le processeur, ces instructions peuvent être classées officieusement de la manière suivante, et afin de mieux comprendre un exemple sera donné pour chaque classe d'instruction:

instructions en 8 bits d'arithmétique/logique | exemple: "INC B", soit incrémenter le registre B. Si B vaut 0x04 avant l'opération. B vaudra 0x05 après.

instructions en 16 bits d'arithmétique/logique | exemple: "INC BC", soit incrémenter le couple de registres BC. Si BC vaut 0x01FF avant l'opération. BC vaudra 0x0200 après, donc B vaudra 0x02 et C vaudra 0x00.

instructions en 8 bits de chargement/sauvegarde/déplacement | exemple: "LD A,C", soit charger le registre C dans le registre A. après l'opération le registre A aura la même valeur que le registre C.

instructions en 16 bits de chargement/sauvegarde/déplacement | exemple: "PUSH BC", soit écrire dans la pile la valeur de BC, la valeur du registre SP s'en retrouvera modifiée.

instructions de sauts et d'appels | exemple: "JP Z,0xHHHH", soit changer le registre PC par l'adresse 0xHHHH si le drapeau Z est activé dans le registre F.

instructions de contrôles/diverses | exemple: "NOP", soit, ne rien faire.

Selon l'instruction, le processeur sait s'il doit lire un, deux ou trois octets (le nombre maximum d'octets lus par le LR35902 par opération est au maximum de 3). Pour mieux comprendre ce mécanisme prenons le cas suivant: 
Le registre PC vaut 0x2000, le registre F vaut 0x80 (Le drapeau Z est à 1), (0x2000) = 0x00, (0x2001) = 0xCA, (0x2002) = 0xEF, (0x2003) = 0xBE.

Comme PC vaut 0x2000 le processeur lit d'abord 0x00 ce qui correspond à l'instruction "NOP", ne rien faire. 
Le processeur ne lira donc qu'un octet pour cette instruction, le registre PC sera incrémenté et vaudra 0x2001.
Ensuite le processeur va lire 0xCA ce qui correspond à l'opération "JP Z,0xHHHH", dans cette opération le processeur a besoin de la valeur 0xHHHH, le processeur va donc lire les 2 octets supplémentaires. Ce qui donne dans ce cas, "JP Z,0xBEEF".
Comme le flag Z est à un, le registre PC vaut 0xBEEF, dans le cas où le flag Z aurait été à 0, PC vaudrait 0x2004.

Les instructions ont des coûts en temps, ces coûts sont représentés en cycles d'exécutions.
Par exemple l'instruction "NOP" coûte 4 cycles, tandis que l'instruction "PUSH BC" coûte 16 cycles.
Certaines instructions selon leur réussite vont avoir des coûts différents, l'instruction "JP Z,0xHHHH" coûtera 16 cycles si le drapeau Z est à 1, 12 sinon.
Le processeur étant cadencé à 4,194304 MHz, un ensemble d'opérations coûtant 4194304 cycles sera réalisé en 1 seconde.

Schéma minimaliste réprésentant Le LR35902:

\section{GPU}
\section{MMU}
le MMU soit Memory Management Unit est un composant qui autorise ou non l'accés en mémoire demandée par le processeur.
En fait la GameBoy ne possède pas de tel composant, seulement le processeur est bien raccordé directement à un espace d'addressage de 16 bits.
Pour mieux comprendre à quoi correspond cet espace, l'espace d'addressage sera
dans un premier temps découpé grossièrement, puis chaque partie sera étudiée
plus en détails:\\
\begin{itemize}
\item \textbf{0xFE00-0xFFFF} Espace mémoire particulier
\item \textbf{0xC000-0xFDFF} RAM interne
\item \textbf{0xA000-0xBFFF} RAM de la cartouche
\item \textbf{0x8000-0x9FFF} RAM interne dédiée aux dessins du jeu
\item \textbf{0x0000-0x7FFF} ROM de la cartouche
\end{itemize}

\subsection{0x0000-0x7FFF ROM de la cartouche}
\begin{itemize}
\item \textbf{0x0000-0x3FFF:} Banque 0 de la ROM de la cartouche.
\item \textbf{0x4000-0x7FFF:} Banque 1-n de la ROM de la cartouche (Voir partie Cartouche de jeu).
\end{itemize}

\subsection{0x8000-0x9FFF RAM interne dédiée aux dessins du jeu}
\begin{itemize}
\item \textbf{0x8000-0x97FF:} Données des dessins, où sont stockés tous les dessins du jeu.
\item \textbf{0x9800-0x9BFF:} "Background Map" 1, zone spécifiant les dessins à utiliser pour dessiner l'arrière plan 1.
\item \textbf{0x9C00-0x9FFF:} "Background Map" 2, zone spécifiant les dessins à utiliser pour dessiner l'arrière plan 2. 
\end{itemize} 

\subsection{0xA000-0xBFFF RAM de la cartouche}
Zone dédiée à la RAM de la cartouche (Voir Partie Cartouche de jeu)

\subsection{0xC000-0xFDFF RAM interne}
\begin{itemize}
\item \textbf{0xC000-0xDFFF:} Zone de RAM interne servant à stocker les différentes variables du jeu.
\item \textbf{0xE000-0xFDFF:} Echo de la plage d'addresse de 0xC000 à 0xDDFF, cette zone est
généralement inutilisée.
\end{itemize} 

\subsection{0xFE00-0xFFFF Espace mémoire particulier}

\begin{itemize}
\item \textbf{0xFE00-0xFE9F:} Object Attribute Memory (OAM), zone contenant les informations
sur les sprites affichés.
\item \textbf{0xFEA0-0xFEFF:} Inutilisé.
\item \textbf{0xFF00-0xFF7F:} Cette zone contient des registres de contrôles pour tous les composants de la
GameBoy.
\item \textbf{0xFF80-0xFFFE:} Cette zone est réservée pour la pile, les
développeurs initialisent généralement le registre SP à l'adresse 0xFFFE.
\item \textbf{0xFFFF :} Cette adresse sert à savoir quelles interruptions sont autorisées ou
non. (Voir partie Interruptions)
\end{itemize} 

\section{APU}
\subsection{Présentation générale}
	La GameBoy dispose de deux cannaux de son (un pour la gauche,
	et un pour la droite), reliés aux terminaux de sortie appelés
	SO1 et SO2 par le constructeur, ainsi que d'un terminal
	d'entré appelé Vin, recevant le signal électrique
	correspondant au son et pouvant être redirigé après
	traitement vers le terminal SO1, SO2, ou les deux en même
	temps (pour passer d'un son mono à un son stéréo par
	exemple).\\

	Grossièrement, les composants de l'appareil permettent de
	créer un son de quatre façons différentes : 
		\begin{itemize}
		\item Une première onde carrée, avec une enveloppe de
		volume et une fonction de balayage.
		\item Une seconde onde carrée avec enveloppe de volume
		aussi mais sans fonction de balayage.
		\item Une onde formée à partir d'échantillons
		prédéfinis et stockés en mémoire cartouche.
		\item Et une onde "Bruit" avec une enveloppe de
		volume.
		\end{itemize}
	Ces quatre ondes sont générées indépendemment et finalement
	"mixées" pour diriger vers les canaux de sortie l'onde
	correspondant au son à produire pour le jeu.

\subsection{Registres, valeurs et contrôles} 
	Pour générer cette musique sans laquelle les jeux n'auraient
	surement pas la même dimension, la console dispose de 22
	registres, qu'elle peut consulter et modifier à quasiment
	n'importe quel moment dès lors que le son du jeu à commencé à
	être joué.\\
	Ces registres sont séparés en 5 "familles" (4 pour les quatre
	ondes, et une pour les contrôles du son) numérotés et appelés
	par convention \textbf{NRXX} ou NR signifie "Noise Register", et XX le
	numéro dudit registre. \\
	Chacun de ces registres peut être utilisé pour stocker une
	ou plusieurs valeurs, en utilisant tout ou seulement une
	partie des 8 bits qu'il contient.\\

	NB : La notation "bits 0 à x" (x = 5 par exemple) signifie
	plus exactement la valeur binaire que l'on obtient en
	extrayant lesdits bits du registre et en les traitant comme un
	nouveau nombre.\\
	Par exemple pour une valeur lue de 01101011 dire "les bits 4 à
	6 donnent la valeur d'un volume" correspond à dire "le nombre binaire
	110 donne la valeur d'un volume".

	\subsubsection{Ton et balayage}
	La première famille comporte cinq registres, utilisés pour
	générer et modifier le premier type d'onde, les ondes carrées
	avec enveloppe de volume et fonction de balayage.\\

		\textbf{NR10(FF10):} le registre de balayage.\\
		C'est le premier exemple de registre utilisé pour
		stocker plusieurs valeurs, ici les bits 4 à 6 donnent
		la valeur de la fréquence de balayge, les bits 0 à 2
		le nombre de décalage de ces balayages à effectuer, et le bit
		numéro 3 indique par sa valeur (0 ou 1) s'il s'agit
		d'un balayage montant (où la fréquence augmente) ou
		d'un balayage descendant (où elle diminue).\\ 
	
	\textbf{NR11(FF11):} Forme d'onde et longueur de son\\
		Les bits 4 à 6 de ce registre contiennent la valeur de
		forme d'onde, chacune des 4 valeurs possibles donne
		une valeur de "temps montant" (1/8 pour 0, 1/4 pour
		1, 1/2 pour 2 et 3/4 pour 3).
		Les bits 0 à 5 donnent la valeur de la longueur
		(periode) du son à jouer. Cette valeur n'est prise en
		compte que si c'est indiqué dans le registre \textbf{NR14}.\\
	
	\textbf{NR12(FF12):} Enveloppe de volume \\
		Les bits 4 à 7 donnent la valeur initiale de volume de
		l'enveloppe.
		Le bit numéro 3 indique la "direction" de l'enveloppe,
		à savoir si le son sera lu avec un volume augmentant
		ou descendant.
		Les bits 0 à 2 donnent la valeur d'un nombre
		d'utilisation de l'enveloppe.\\ 
	
	\textbf{NR13(FF13):} Composantes basses de la fréquence \\
		La fréquence du son à jouer est un nombre sur 11 bits
		dont les 8 représentant la composante basse sont
		stockés ici et les 3 manquants représentant la
		composante haute sont stockés dans le registre
		suivant.\\ 

		\textbf{NR14(FF14)}: Composantes hautes \\
		Le bit 7 est un indicateur de réinitialisation de la
		fréquence, le bit 6 un compteur d'opérations
		consecutives, qui va indiquer si la longueur lue sur
		les bits 0 à 5 du registre \textbf{NR11} est à prendre en
		compte ou non, et les bits 0 à 2 contiennent les 3 bits
		manquant à la fréquence stockée en \textbf{NR13}.
		\subsubsection{Ton}
		La deuxième famille correspond à la deuxième onde carrée, elle
		fonctionne comme la première mais sans le registre de
		balayage. Le fonctionnement, l'ordre et les valeurs des bits
		correspondent aux mêmes descriptions que pour la première
		famille, la seule différence réside dans les registres
		utilisés.\\ \\
	
	Le registre \textbf{NR21(FF16)} fonctionne comme le \textbf{NR11} (à
		l'exception de la vérification de prise en compte de
		la longueur, qui se fait via le bit 6 du registre \textbf{NR24}
		cette fois-ci), le \textbf{NR22(FF17)} fonctionne comme le
		\textbf{NR12}, le \textbf{NR23(FF18)} fonctionne comme le \textbf{NR13} et le
		\textbf{NR24(FF19)} comme le \textbf{NR14}. 
			
		\subsubsection{Onde mémoire}
		Cette famille de registres correspond principalement à
		l'utilisation de sons pré-enregistrés dans la cartouche
		(et certains dans la gameboy, le bruit de démarrage par
		exemple).
		Dans certains cas elle peut être utilisé pour jouer un son de
		la même façon que les 2 premières ondes, ce qui explique la
		présence des registres \textbf{NR33} et \textbf{NR34}. \\ 
		
		\textbf{NR30(FF1A):} Trigger de son \\ 
		Il n'est utilisé que pour indiquer via la
		valeur du bit 7 si l'onde mémoire est à utiliser ou
		non.\\
		
		\textbf{NR31(FF1B):} Longueur de son \\
		La valeur entière (bits 0 à 7) du
		registre est utilisée et donne la longueur du son à
		jouer.\\ 
		
		\textbf{NR32(FF1C):} Selecteur \\
		Les bits 5 à 6 donne la valeur d'un
		selecteur de volume pour le son à jouer, il est joué
		sans son pour une valeur de 0, tel quel pour 1, avec un volume à 50pourcents 
		pour 2 (décalé d'un bit vers la droite), et un volume
		de 25pourcents pour 3 (décalé de deux bits vers la droite). \\
		
		\textbf{NR33(FF1D):} Composantes basses \\
		Comme pour les \textbf{NR13} et \textbf{NR23}, ce registre
		contient les 8 premiers bits de la valeur de fréquence
		du son à jouer.\\

		\textbf{NR34(FF1E):} Composantes hautes \\
		Celui-ci fonctionne comme les \textbf{NR14} et \textbf{NR24} mais pour
		cette 3eme onde (utilisé dans le cas d'une utilisation
		de cette onde pour produire un son sans utiliser les
		sons mémoire). \\

		Les registres \textbf{FF30} à \textbf{FF3F} ne sont pas numérotés en NR
		mais contiennent les sons pré-enregistrés à jouer, ils
		sont stockés sous la forme de 32 échantillons de 4
		bits chacun, soit 16 valeurs 8 bits lues dans l'ordre
		4 bits de poids fort en premier et 4 bits de poids
		faible ensuite.

	\subsubsection{Bruit}
		Cette famille de registre correspond à une onde de son
		appelé "bruit blanc", c'est généralement d'elle que
		vienne les sont saturés que l'on entend dans la
		plupart des jeux (une brique cassée dans Super Mario
		par exemple!). 
		Ce bruit est réalisé par une variation aléatoire
		d'amplitude entre composantes hautes et basses d'une
		fréquence donnée. Le son paraitra plus ou moins rude
		en fonction de cette fréquence. \\
		Cette onde est aussi parfois utilisée pour générer un
		son correct en régularisant la sortie par une
		modification volontaire de la modification aléatoire
		d'amplitude (qui par conséquent, n'est plus réellement
		due au hasard). \\

		\textbf{NR41(FF20):} Longueur de son \\
		Les bits 0 à 5 donnent la valeur de la longueur du son
		à jouer.\\

		\textbf{NR42(FF21):} Enveloppe de volume\\
		Les bits 4 à 7 correspondent à la valeur initiale de
		l'enveloppe, le bit numéro 3 donne sa direction
		(montante ou descendante) et les bits 0 à 2 donnent le
		nombre d'utilisations de l'enveloppe.\\ 

		\textbf{NR43(FF22):} Compteur polynomial \\
		L'amplitude est modifiée aléatoirement entre haute et
		basse sur la fréquence donnée. Plus cette fréquence
		est haute, moins le bruit paraitre rude. 
		Si le bit 3 est activé, l'intervalle de valeurs
		aléatoires est réduit, et la sortie devient plus
		régulière, rendant la sortie plus proche d'un réel
		son que d'un bruit (au sens mathématique du terme).
		Les bits 4 à 7 donnent la fréquence utilisée, le bit 3
		indique la taille de l'intervalle des valeurs
		aléatoires d'amplitude et les bits 0 à 2 correspondent
		à une valeur de diviseur de fréquence.\\ 

		\textbf{FF23(NR43):} Compteur consécutif\\
		Le bit 7 est un initialiseur, il réinitialise le bruit
		lorsque sa valeur est 1.
		Le bit 6 est l'indicateur de jeu du son, il indique
		qu'il faut stopper en passant à 0 lorsque la valeur de
		longueur du son lue en \textbf{NR41} tombe à 0. 
	\subsubsection{Contrôles du son}
		C'est la cinquième et ultime famille de registres
		utilisés pour produire du son avec la console, elle
		correspond à un ensembles de registres dont les
		valeurs servent à contrôler physiquement dans son
		ensemble, par exemple indiquer le canal de sortie,
		gérer le volume général ou simplement activer ou
		désactiver le son de la console. \\

		\textbf{NR50(FF24):} Controle du signal d'entrée \\ 
		Le bit 7 envoie le signal Vin vers la sortie SO2
		lorsqu'il est activé, alors que le bit 3 l'envoie vers
		la sortie SO1. les bits 6 à 4 correspondent au volume
		propre à la SO2, et les 0 à 2 à celui de la SO1. \\

		\textbf{NR51(FF25):} Sélection du terminal de sortie propre \\
		Ici les bits redirige les 4 ondes possibles vers un
		terminal donné.
		Les bits 0 à 3 envoie respectivement les ondes 1 à 4
		vers la SO1, les bits 4 à 7 envoie respectivement les
		ondes 1 à 4 vers la SO2.\\

		\textbf{NR52(FF26):} Activation du son \\
		Les bits 0 à 3 de ce registre activent (ou
		desactivent) respectivement les ondes 1 à 4 et le bit
		7 indique si le son général de la console est activé
		ou non.
\section{Interruptions/Synchronisations}
Comme vu dans les parties précédentes, le processeur de la GameBoy travaille conjointement avec d'autres composants. Afin d'éviter un chaos général voir l'endommagement de certains composants, un système d'interruptions a été intégré dans l'architecture de la GameBoy.
\subsection{Que fait une interruption?}
Lorsqu'une interruption est déclenchée, le processeur va interrompre ses calculs afin d'exécuter une routine. Pour cela lorsqu'une interruption est déclenchée le processeur va ajouter dans la pile le registre PC et remplacer la valeur du registre PC par l'adresse de la routine. L'adresse de la routine est différente selon le type d'interruption déclenchée.
\subsection{Registres d'interruption}
Afin qu'une interruption soit déclenchée il faut qu'un certain nombre de conditions soient réunies.
\subsubsection{Registre IME}
En premier lieu le processeur dispose d'un registre spécial appelé IME (Interrupt Master Enabled), qui va contrôler si les interruptions peuvent être déclenchées ou non. Si IME est à 0 aucune interruption ne sera déclenchée, sinon si IME est à 1 les interruptions peuvent être déclenchées.
\subsubsection{Registres IE et IF} 
IE correspond à 'Interrupt Enable' et IF correspond à 'Interrupt Flag', ces deux registres sont stockées en mémoire. IE est disponible à l'adresse 0xFFFF et IF à l'adresse 0xFF0F. Le registres IE signale quelles interruptions peuvent être déclenchées. Le registre IF signale quelles interruptions veulent être déclenchées.
Comme il existe cinq types d'interruptions, cinq bits de ces registres vont servir à savoir quelle interruption est demandée/activée:\\\\
\textbf{0xFFFF - IE - Interrupt Enable} \\
Bit 0: V-Blank  Interruption Autorisée  (1=Autorisée)\\
Bit 1: LCD STAT Interruption Autorisée  (1=Autorisée)\\
Bit 2: Timer    Interruption Autorisée  (1=Autorisée)\\
Bit 3: Serial   Interruption Autorisée  (1=Autorisée)\\
Bit 4: Joypad   Interruption Autorisée  (1=Autorisée)\\\\
\textbf{0xFF0F - IF - Interrupt Flag} \\
Bit 0: V-Blank  Requête d'Interruption  (1=Requête)\\
Bit 1: LCD STAT Requête d'Interruption  (1=Requête)\\
Bit 2: Timer    Requête d'Interruption  (1=Requête)\\
Bit 3: Serial   Requête d'Interruption  (1=Requête)\\
Bit 4: Joypad   Requête d'Interruption  (1=Requête)\\\\

\subsection{Quand est-ce qu'une interruption est déclenchée?}
Pour qu'une interruption soit déclenchée, par exemple l'interruption VBlank, Il faut que IME soit à 1, et que les bits 0 de IE et IF soit à 1 également.
Lorsqu'elle sera déclenchée le bit 0 de IF sera mis à 0. IME sera mis à 0 également pour éviter qu'une interruption soit déclenchée pendant la routine d'une autre interruption (bien que celà soit possible pour le développeur en utilisant l'instruction "EI" dans une routine d'interruption).
\subsection{Les différents types d'interruptions}
\subsubsection{Interruption VBlank}
L'interruption VBlank est demandée par l'écran LCD, cette demande est faites à chaque fois que l'écran rentre dans la période de VBlank (Voir partie GPU), l'interruption sert généralement à mettre à jour les dessins du jeu avant l'affichage d'une nouvelle image. La routine se trouve à l'adresse 0x0040.
\subsubsection{Interruption LCD STAT}
Cette interruption est également demandée par l'écran LCD, elle sert généralement à executer des routines lorsque l'écran LCD change d'état (Voir partie GPU). Elle peut aussi intervenir lorsque la ligne actuellement dessinée par l'écran LCD correspond au registre LYC (LY compare) situé à l'adresse 0xFF45. la routine se trouve à l'adresse 0x0048.
\subsubsection{Interruption Timer}
Interruption générée par le timer interne de la GameBoy, à chaque fois que celui ci dépasse une certaine durée. La routine se trouve à l'adresse 0x0050.
\subsubsection{Interruption Serial}
Interruption générée lorsqu'un transfert d'un octet à été fait (reçu ou transmis) à l'aide du câble Link servant à communiquer entre deux GameBoy ou entre une GameBoy et un ordinateur. La routine se trouve à l'adresse 0x0058.
\subsubsection{Interruption Joypad}
Interruption générée lors de l'appui sur une touche par le joueur. La routine se trouve à l'adresse 0x0060.
\chapter{Réalisation}
\section{CPU}
\section{GPU}
\section{MMU}
\section{APU}
\section{Interruptions/Synchronisations}
\section{Fonctionnalités additionnelles}
\chapter{Conclusion}
\section{Bilan}
\section{Fonctionnalités pouvant être rajoutées}
\section{Emulation aujourd'hui}

%annexes
\appendix
\chapter{Générer un son en temps réel et sans fichier avec la SDL}
\chapter{Charger et créer une police au format BMP sans recours à une librairie externe avec SDL}
\chapter{Méthodes de débuggage et roms de test}
\end{document}
